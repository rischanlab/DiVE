% ============================================== %
% PRELIMINARIES %
% ============================================== %

\section{PRELIMINARIES AND RELATED WORK}
\subsection{View Recommendation}

% Visualization Recommendation System explanation %
As in our example above, consider a visual data exploration session that begins by an analyst submitting a query $Q$ on a multi-dimensional database $D_B$ to be visually analyzed. Assume that the analyst desires to select a subset of $D_B$  by specifying a query predicate $T$. Hence, a general format for query $Q$ can be defined as: 

\bigskip
$Q$ = SELECT * FROM $D_B$ WHERE $T$;
\bigskip

The result of $Q$ is $D_Q$ which is a subset of $D_B$ that need to be visualized.

In order to generate visualizations for $D_Q$, the $D_B$ consists of a set of dimensional attributes $\mathbb{A}$ and a set of measure attributes $\mathbb{M}$. Also, let $\mathbb{F}$ be a set of possible aggregate functions over measure attributes, such as COUNT, AVG, SUM, MIN and MAX. As in \cite{Vartak2015}, using different combinations of dimension and measure attributes along with various aggregate functions, and specifying GROUP BY, it is possible to execute aggregate queries over $D_Q$.  %Each aggregate query generates a two column result, where column one consists of attribute dimension values and second column presents the corresponding aggregate function values on measure attribute.The result generated by the aggregate query can be easily visualized as bar charts. 
Therefore, a possible aggregate view $V_i$ of the example query $Q$ is constituted by a tuple ($ A $, $ M $, $ F $) where $A \in \mathbb{A}$, $M\in \mathbb{M}$, and  $F \in \mathbb{F}$, and it can be formally defined as:

\bigskip
$V_i$  = SELECT $A$, $F$ ($M$) FROM $D_B$ WHERE $T$ GROUP BY $A$;
\bigskip

Generally, an analyst migth be interested to find view $V_i$ that reveal interesting insights over $D_Q$. However, manually generate all possible views over $D_Q$ by changing the combination of all $ \mathbb{A} $, $ \mathbb{M} $, and $ \mathbb{F} $, one by one is wasting time. In fact, there have been proposed approaches for automatically recommend interesting views based on quantitative metrics\cite{Key2012}, \cite{Viegas2007}, \cite{Vartak2014}, \cite{Vartak2015}, \cite{Ehsan2016}. One recent approach \cite{Vartak2015} recommend top-k views according to some metric of importance which is called \textit{deviation-based metric}. This metric measures the distance between aggregate view $V_i$ over $D_Q$ and $V_i$ over data set can either be another subset of $D_B$ called as reference subset $D_R$ or whole $D_B$, where $V_i(D_Q)$ is expressed as \textit{target view}, wheres $V_i(D_R)$ is expressed as \textit{reference view}. 

For instance, consider again our example in introduction section. Let $D_B$ be Cleveland heart disease data table (e.g., tb\_heart\_disease). The analyst wants to do comparison between people with heart disease (disease) and people without heart disease (no disease). This example leads us to the two subsets which are disease subset as the target subset $D_Q$ and no disease subset as the reference subset $D_R$.
%Hence, each of the subset, leads to a unique visualization called a target view denoted as $V_T$ and a reference view denoted as $V_R$. We can formally define as: 
The attribute and measure dimensions of Cleveland heart disease dataset $D_B$ which are; $\mathbb{A}$ =  (chest\_pain\_types), $\mathbb{M}$ = (age, oldpeak) and $\mathbb{F}$ = (COUNT, AVG, SUM, MIN and MAX). 
%The query predicate $T_T$ is \quotes{status = Disease}, this predicate generates a subset $D_T$ of $D_B$ that contains data of all patients with heart disease. Meanwhile, the query predicate $T_R$ is \quotes{status = No Disease} which generate subset $D_R$ of $D_B$ and it consists the data of all patients without heart disease. 
Using those various combinations of attributes, measures and aggregate functions, it is possible to generate 2 * | $\mathbb{A}$ |*| $\mathbb{M}$ |*| $\mathbb{F}$ | = 2*(1*2*5) = 20 views. As the example, the views shown in Figure \ref{fig:intro1} and \ref{fig:intro2} correspond to $A$=\quotes{chest\_pain\_types}, $M$=\quotes{age}, \quotes{oldpeak}, and $F$=\quotes{Avg}. In addition, the view of Figure \ref{fig:intro3}  corresponds to $A$=\quotes{chest\_pain\_types}, $M$=\quotes{oldpeak}, and $F$=\quotes{Max}.

It is clear from the above example that even for a modest dataset that only has one attribute and two meassure attributes, the number of possible views to consider can be large. Also, not all the views will be of interest to the user. Therefore, in order to reduce the user effort, it is very important to recommend a set of few \quotes{most important} views. The challenge, however, is to determine what constitutes the most imporant of set of views. The existing visualization recommendation systems techniques rely mainly on the content of the view in terms of data generated as a result of the underlying aggregate query\cite{Vartak2015}, \cite{Vartak2014}. Those exiting approaches lead to recommend similar views as explained in the introduction section.%The recommendation approach results in a set of views that are individually interesting in reference to some other subset of data or the whole data set. Since the views are recommended as a collection or set of multiple views, the quality of the whole set is as important as the quality of individual views\cite{Vartak2017}. 

Therefore, in this work, we consider the content of a view as well as its context. The content of a view is determined by the data presented in the view and the context of the view is determined from the attributes, meassures and aggregate functions of the query. 
%\bigskip
%$V_{Tcontent}$ = SELECT $A, F$($M$) FROM $D_Q$ GROUP BY $A$;
%
%$V_{Tcontext}$= [$A, F, M$]
%\bigskip
